Dịch các chuỗi ứng dụng Legado này từ tiếng Trung sang tiếng Việt:

**DỰ ÁN**: Legado - Ứng dụng đọc sách Android mã nguồn mở
**BỐI CẢNH**: Ứng dụng đọc sách với các tính năng:
- Quản lý nguồn sách
- Giao diện đọc tùy chỉnh
- Text-to-Speech (TTS)
- Nhập/Xuất dữ liệu
- Dịch vụ web

**YÊU CẦU DỊCH**:
- Tiếng Việt tự nhiên, thân thiện với người dùng mobile
- Giữ định dạng CSV hoàn toàn giống nhau
- Chỉ điền cột "translation"
- Giữ nguyên các placeholder như %s, %d, \n
- Sử dụng thuật ngữ nhất quán

**TỪ VỰNG CHUẨN**:
- 阅读 = Đọc sách
- 书源 = Nguồn sách
- 书架 = Kệ sách
- 朗读 = Đọc to / TTS
- 搜索 = Tìm kiếm
- 设置 = Cài đặt
- 导入 = Nhập
- 导出 = Xuất
- 备份 = Sao lưu
- 恢复 = Khôi phục
- 刷新 = Làm mới
- 缓存 = Bộ nhớ đệm
- 主题 = Giao diện
- 界面 = Giao diện
- 管理 = Quản lý
- 编辑 = Chỉnh sửa
- 删除 = Xóa
- 添加 = Thêm
- 分享 = Chia sẻ
- 下载 = Tải về
- 更新 = Cập nhật
- 目录 = Mục lục
- 章节 = Chương
- 页面 = Trang
- 字体 = Phông chữ
- 亮度 = Độ sáng
- 背景 = Nền
- 颜色 = Màu sắc

**PHONG CÁCH DỊCH**:
- Ngôn ngữ giao diện mobile (ngắn gọn, rõ ràng)
- Thân thiện, không quá kỹ thuật
- Theo chuẩn Android bằng tiếng Việt
- Text nút bấm ngắn (dưới 20 ký tự)
- Menu items mô tả nhưng súc tích

Dữ liệu CSV cần dịch:
id,type,file_path,line_number,string_name,original_text,translation,context,notes
5001,source_code,app\src\main\java\io\legado\app\model\analyzeRule\RuleAnalyzer.kt,75,,不更改类本身的位置,,var pos = pos //声明新变量记录匹配位置，不更改类本身的位置,Chinese parts: 不更改类本身的位置
5002,source_code,app\src\main\java\io\legado\app\model\analyzeRule\RuleAnalyzer.kt,79,,匹配则返回位置,,queue[pos] == s) return pos //匹配则返回位置,Chinese parts: 匹配则返回位置
5003,source_code,app\src\main\java\io\legado\app\model\analyzeRule\RuleAnalyzer.kt,81,,逐个试探,,pos++ //逐个试探,Chinese parts: 逐个试探
5004,source_code,app\src\main\java\io\legado\app\model\analyzeRule\RuleAnalyzer.kt,93,,声明临时变量记录匹配位置,,var pos = pos //声明临时变量记录匹配位置，匹配成功后才同步到类的pos,Chinese parts: 声明临时变量记录匹配位置
5005,source_code,app\src\main\java\io\legado\app\model\analyzeRule\RuleAnalyzer.kt,93,,匹配成功后才同步到类的,,var pos = pos //声明临时变量记录匹配位置，匹配成功后才同步到类的pos,Chinese parts: 匹配成功后才同步到类的
5006,source_code,app\src\main\java\io\legado\app\model\analyzeRule\RuleAnalyzer.kt,95,,嵌套深度,,var depth = 0 //嵌套深度,Chinese parts: 嵌套深度
5007,source_code,app\src\main\java\io\legado\app\model\analyzeRule\RuleAnalyzer.kt,96,,其他对称符合嵌套深度,,var otherDepth = 0 //其他对称符合嵌套深度,Chinese parts: 其他对称符合嵌套深度
5008,source_code,app\src\main\java\io\legado\app\model\analyzeRule\RuleAnalyzer.kt,98,,单引号,,var inSingleQuote = false //单引号,Chinese parts: 单引号
5009,source_code,app\src\main\java\io\legado\app\model\analyzeRule\RuleAnalyzer.kt,99,,双引号,,var inDoubleQuote = false //双引号,Chinese parts: 双引号
5010,source_code,app\src\main\java\io\legado\app\model\analyzeRule\RuleAnalyzer.kt,104,,非转义字符,,if (c != ESC) { //非转义字符,Chinese parts: 非转义字符
5011,source_code,app\src\main\java\io\legado\app\model\analyzeRule\RuleAnalyzer.kt,105,,匹配具有语法功能的单引号,,ingleQuote = !inSingleQuote //匹配具有语法功能的单引号,Chinese parts: 匹配具有语法功能的单引号
5012,source_code,app\src\main\java\io\legado\app\model\analyzeRule\RuleAnalyzer.kt,106,,匹配具有语法功能的双引号,,oubleQuote = !inDoubleQuote //匹配具有语法功能的双引号,Chinese parts: 匹配具有语法功能的双引号
5013,source_code,app\src\main\java\io\legado\app\model\analyzeRule\RuleAnalyzer.kt,108,,语法单元未匹配结束,,|| inDoubleQuote) continue //语法单元未匹配结束，直接进入下个循环,Chinese parts: 语法单元未匹配结束
5014,source_code,app\src\main\java\io\legado\app\model\analyzeRule\RuleAnalyzer.kt,108,,直接进入下个循环,,leQuote) continue //语法单元未匹配结束，直接进入下个循环,Chinese parts: 直接进入下个循环
5015,source_code,app\src\main\java\io\legado\app\model\analyzeRule\RuleAnalyzer.kt,110,,开始嵌套一层,,if (c == '[') depth++ //开始嵌套一层,Chinese parts: 开始嵌套一层
5016,source_code,app\src\main\java\io\legado\app\model\analyzeRule\RuleAnalyzer.kt,111,,闭合一层嵌套,,else if (c == ']') depth-- //闭合一层嵌套,Chinese parts: 闭合一层嵌套
5017,source_code,app\src\main\java\io\legado\app\model\analyzeRule\RuleAnalyzer.kt,120,,拉出一个平衡字串,,epth > 0 || otherDepth > 0) //拉出一个平衡字串,Chinese parts: 拉出一个平衡字串
5018,source_code,app\src\main\java\io\legado\app\model\analyzeRule\RuleAnalyzer.kt,123,,同步位置,,this.pos = pos //同步位置,Chinese parts: 同步位置
5019,source_code,app\src\main\java\io\legado\app\model\analyzeRule\RuleAnalyzer.kt,133,,声明临时变量记录匹配位置,,var pos = pos //声明临时变量记录匹配位置，匹配成功后才同步到类的pos,Chinese parts: 声明临时变量记录匹配位置
5020,source_code,app\src\main\java\io\legado\app\model\analyzeRule\RuleAnalyzer.kt,133,,匹配成功后才同步到类的,,var pos = pos //声明临时变量记录匹配位置，匹配成功后才同步到类的pos,Chinese parts: 匹配成功后才同步到类的
5021,source_code,app\src\main\java\io\legado\app\model\analyzeRule\RuleAnalyzer.kt,134,,嵌套深度,,var depth = 0 //嵌套深度,Chinese parts: 嵌套深度
5022,source_code,app\src\main\java\io\legado\app\model\analyzeRule\RuleAnalyzer.kt,135,,单引号,,var inSingleQuote = false //单引号,Chinese parts: 单引号
5023,source_code,app\src\main\java\io\legado\app\model\analyzeRule\RuleAnalyzer.kt,136,,双引号,,var inDoubleQuote = false //双引号,Chinese parts: 双引号
5024,source_code,app\src\main\java\io\legado\app\model\analyzeRule\RuleAnalyzer.kt,141,,匹配具有语法功能的单引号,,ingleQuote = !inSingleQuote //匹配具有语法功能的单引号,Chinese parts: 匹配具有语法功能的单引号
5025,source_code,app\src\main\java\io\legado\app\model\analyzeRule\RuleAnalyzer.kt,142,,匹配具有语法功能的双引号,,oubleQuote = !inDoubleQuote //匹配具有语法功能的双引号,Chinese parts: 匹配具有语法功能的双引号
5026,source_code,app\src\main\java\io\legado\app\model\analyzeRule\RuleAnalyzer.kt,144,,语法单元未匹配结束,,|| inDoubleQuote) continue //语法单元未匹配结束，直接进入下个循环,Chinese parts: 语法单元未匹配结束
5027,source_code,app\src\main\java\io\legado\app\model\analyzeRule\RuleAnalyzer.kt,144,,直接进入下个循环,,leQuote) continue //语法单元未匹配结束，直接进入下个循环,Chinese parts: 直接进入下个循环
5028,source_code,app\src\main\java\io\legado\app\model\analyzeRule\RuleAnalyzer.kt,145,,不在引号中的转义字符才将下个字符转义,,else if (c == '\\') { //不在引号中的转义字符才将下个字符转义,Chinese parts: 不在引号中的转义字符才将下个字符转义
5029,source_code,app\src\main\java\io\legado\app\model\analyzeRule\RuleAnalyzer.kt,150,,开始嵌套一层,,if (c == open) depth++ //开始嵌套一层,Chinese parts: 开始嵌套一层
5030,source_code,app\src\main\java\io\legado\app\model\analyzeRule\RuleAnalyzer.kt,151,,闭合一层嵌套,,lse if (c == close) depth-- //闭合一层嵌套,Chinese parts: 闭合一层嵌套
5031,source_code,app\src\main\java\io\legado\app\model\analyzeRule\RuleAnalyzer.kt,153,,拉出一个平衡字串,,} while (depth > 0) //拉出一个平衡字串,Chinese parts: 拉出一个平衡字串
5032,source_code,app\src\main\java\io\legado\app\model\analyzeRule\RuleAnalyzer.kt,156,,同步位置,,this.pos = pos //同步位置,Chinese parts: 同步位置
5033,source_code,app\src\main\java\io\legado\app\model\analyzeRule\RuleAnalyzer.kt,165,,首段匹配,,"tring): ArrayList<String> { //首段匹配,elementsType为空",Chinese parts: 首段匹配
5034,source_code,app\src\main\java\io\legado\app\model\analyzeRule\RuleAnalyzer.kt,165,,为空,,"<String> { //首段匹配,elementsType为空",Chinese parts: 为空
5035,source_code,app\src\main\java\io\legado\app\model\analyzeRule\RuleAnalyzer.kt,168,,设置分割字串,,elementsType = split[0] //设置分割字串,Chinese parts: 设置分割字串
5036,source_code,app\src\main\java\io\legado\app\model\analyzeRule\RuleAnalyzer.kt,173,,设置分隔符长度,,step = elementsType.length //设置分隔符长度,Chinese parts: 设置分隔符长度
5037,source_code,app\src\main\java\io\legado\app\model\analyzeRule\RuleAnalyzer.kt,175,,递归匹配,,} //递归匹配,Chinese parts: 递归匹配
5038,source_code,app\src\main\java\io\legado\app\model\analyzeRule\RuleAnalyzer.kt,176,,未找到分隔符,,(!consumeToAny(* split)) { //未找到分隔符,Chinese parts: 未找到分隔符
5039,source_code,app\src\main\java\io\legado\app\model\analyzeRule\RuleAnalyzer.kt,181,,记录分隔位置,,val end = pos //记录分隔位置,Chinese parts: 记录分隔位置
5040,source_code,app\src\main\java\io\legado\app\model\analyzeRule\RuleAnalyzer.kt,182,,重回开始,,pos = start //重回开始，启动另一种查找,Chinese parts: 重回开始
5041,source_code,app\src\main\java\io\legado\app\model\analyzeRule\RuleAnalyzer.kt,182,,启动另一种查找,,pos = start //重回开始，启动另一种查找,Chinese parts: 启动另一种查找
5042,source_code,app\src\main\java\io\legado\app\model\analyzeRule\RuleAnalyzer.kt,185,,查找筛选器位置,,"al st = findToAny('[', '(') //查找筛选器位置",Chinese parts: 查找筛选器位置
5043,source_code,app\src\main\java\io\legado\app\model\analyzeRule\RuleAnalyzer.kt,189,,压入分隔的首段规则到数组,,"eue.substring(startX, end)) //压入分隔的首段规则到数组",Chinese parts: 压入分隔的首段规则到数组
5044,source_code,app\src\main\java\io\legado\app\model\analyzeRule\RuleAnalyzer.kt,191,,设置组合类型,,".substring(end, end + step) //设置组合类型",Chinese parts: 设置组合类型
5045,source_code,app\src\main\java\io\legado\app\model\analyzeRule\RuleAnalyzer.kt,192,,跳过分隔符,,pos = end + step //跳过分隔符,Chinese parts: 跳过分隔符
5046,source_code,app\src\main\java\io\legado\app\model\analyzeRule\RuleAnalyzer.kt,194,,循环切分规则压入数组,,(consumeTo(elementsType)) { //循环切分规则压入数组,Chinese parts: 循环切分规则压入数组
5047,source_code,app\src\main\java\io\legado\app\model\analyzeRule\RuleAnalyzer.kt,196,,跳过分隔符,,pos += step //跳过分隔符,Chinese parts: 跳过分隔符
5048,source_code,app\src\main\java\io\legado\app\model\analyzeRule\RuleAnalyzer.kt,199,,将剩余字段压入数组末尾,,ule += queue.substring(pos) //将剩余字段压入数组末尾,Chinese parts: 将剩余字段压入数组末尾
5049,source_code,app\src\main\java\io\legado\app\model\analyzeRule\RuleAnalyzer.kt,204,,先匹配到,,if (st > end) { //先匹配到st1pos，表明分隔字串不在选择器中，将选择器前分隔字串分,Chinese parts: 先匹配到
5050,source_code,app\src\main\java\io\legado\app\model\analyzeRule\RuleAnalyzer.kt,204,,表明分隔字串不在选择器中,,if (st > end) { //先匹配到st1pos，表明分隔字串不在选择器中，将选择器前分隔字串分隔的字段依次压入数组,Chinese parts: 表明分隔字串不在选择器中
