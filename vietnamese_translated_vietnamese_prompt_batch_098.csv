id,type,file_path,line_number,string_name,original_text,translation,context,notes
4851,source_code,app\src\main\java\io\legado\app\model\analyzeRule\AnalyzeByJSonPath.kt,80,,为空,Trống,"if (st.isEmpty()) { //st为空，表明无成功替换的内嵌规则",Chinese parts: 为空
4852,source_code,app\src\main\java\io\legado\app\model\analyzeRule\AnalyzeByJSonPath.kt,80,,表明无成功替换的内嵌规则,Không có quy tắc nhúng nào được thay thế thành công,"if (st.isEmpty()) { //st为空，表明无成功替换的内嵌规则",Chinese parts: 表明无成功替换的内嵌规则
4853,source_code,app\src\main\java\io\legado\app\model\analyzeRule\AnalyzeByJSonPath.kt,132,,设置平衡组为代码平衡,Đặt nhóm cân bằng là cân bằng mã,"= RuleAnalyzer(rule, true) //设置平衡组为代码平衡",Chinese parts: 设置平衡组为代码平衡
4854,source_code,app\src\main\java\io\legado\app\model\analyzeRule\AnalyzeByJSoup.kt,155,,修剪当前规则之前的,Cắt bỏ trước quy tắc hiện tại,"rsRule.trim()  // 修剪当前规则之前的""@""或者空白符",Chinese parts: 修剪当前规则之前的
4855,source_code,app\src\main\java\io\legado\app\model\analyzeRule\AnalyzeByJSoup.kt,155,,或者空白符,hoặc khoảng trắng,"rsRule.trim()  // 修剪当前规则之前的""@""或者空白符",Chinese parts: 或者空白符
4856,source_code,app\src\main\java\io\legado\app\model\analyzeRule\AnalyzeByJSoup.kt,208,,创建解析,Tạo trình phân tích,ule = RuleAnalyzer(ruleStr) //创建解析,Chinese parts: 创建解析
4857,source_code,app\src\main\java\io\legado\app\model\analyzeRule\AnalyzeByJSoup.kt,210,,修建前置赘余符号,Cắt bỏ ký tự thừa ở đầu,rule.trim() //修建前置赘余符号,Chinese parts: 修建前置赘余符号
4858,source_code,app\src\main\java\io\legado\app\model\analyzeRule\AnalyzeByJSoup.kt,212,,切割成列表,Cắt thành danh sách,"ules = rule.splitRule(""@"") // 切割成列表",Chinese parts: 切割成列表
4859,source_code,app\src\main\java\io\legado\app\model\analyzeRule\AnalyzeByJSoup.kt,305,,执行索引列表处理器,Thực thi bộ xử lý danh sách chỉ mục,findIndexSet(rule) //执行索引列表处理器,Chinese parts: 执行索引列表处理器
4860,source_code,app\src\main\java\io\legado\app\model\analyzeRule\AnalyzeByJSoup.kt,311,,允许索引直接作为根元素,Cho phép chỉ mục làm phần tử gốc,.isEmpty()) temp.children() //允许索引直接作为根元素，此时前置规则为空，效果与children相同,Chinese parts: 允许索引直接作为根元素
4861,source_code,app\src\main\java\io\legado\app\model\analyzeRule\AnalyzeByJSoup.kt,311,,此时前置规则为空,Khi đó, quy tắc tiền tố trống,temp.children() //允许索引直接作为根元素，此时前置规则为空，效果与children相同,Chinese parts: 此时前置规则为空
4862,source_code,app\src\main\java\io\legado\app\model\analyzeRule\AnalyzeByJSoup.kt,311,,效果与,Hiệu quả tương tự,dren() //允许索引直接作为根元素，此时前置规则为空，效果与children相同,Chinese parts: 效果与
4863,source_code,app\src\main\java\io\legado\app\model\analyzeRule\AnalyzeByJSoup.kt,311,,相同,giống,索引直接作为根元素，此时前置规则为空，效果与children相同,Chinese parts: 相同
4864,source_code,app\src\main\java\io\legado\app\model\analyzeRule\AnalyzeByJSoup.kt,315,,允许索引直接作为根元素,Cho phép chỉ mục làm phần tử gốc,"hildren"" -> temp.children() //允许索引直接作为根元素，此时前置规则为空，效果与children相同",Chinese parts: 允许索引直接作为根元素
4865,source_code,app\src\main\java\io\legado\app\model\analyzeRule\AnalyzeByJSoup.kt,315,,此时前置规则为空,Khi đó, quy tắc tiền tố trống,temp.children() //允许索引直接作为根元素，此时前置规则为空，效果与children相同,Chinese parts: 此时前置规则为空
4866,source_code,app\src\main\java\io\legado\app\model\analyzeRule\AnalyzeByJSoup.kt,315,,效果与,Hiệu quả tương tự,dren() //允许索引直接作为根元素，此时前置规则为空，效果与children相同,Chinese parts: 效果与
4867,source_code,app\src\main\java\io\legado\app\model\analyzeRule\AnalyzeByJSoup.kt,315,,相同,giống,索引直接作为根元素，此时前置规则为空，效果与children相同,Chinese parts: 相同
4868,source_code,app\src\main\java\io\legado\app\model\analyzeRule\AnalyzeByJSoup.kt,331,,为空,Trống,tIndexes downTo 0) { //indexes为空，表明是非[]式索引，集合是逆向遍历插入的，所以这里也逆向遍,Chinese parts: 为空
4869,source_code,app\src\main\java\io\legado\app\model\analyzeRule\AnalyzeByJSoup.kt,331,,表明是非,Cho thấy không phải,dexes downTo 0) { //indexes为空，表明是非[]式索引，集合是逆向遍历插入的，所以这里也逆向遍历，好还原,Chinese parts: 表明是非
4870,source_code,app\src\main\java\io\legado\app\model\analyzeRule\AnalyzeByJSoup.kt,331,,式索引,chỉ mục kiểu,downTo 0) { //indexes为空，表明是非[]式索引，集合是逆向遍历插入的，所以这里也逆向遍历，好还原顺序,Chinese parts: 式索引
4871,source_code,app\src\main\java\io\legado\app\model\analyzeRule\AnalyzeByJSoup.kt,331,,集合是逆向遍历插入的,Tập hợp được chèn theo thứ tự ngược,To 0) { //indexes为空，表明是非[]式索引，集合是逆向遍历插入的，所以这里也逆向遍历，好还原顺序,Chinese parts: 集合是逆向遍历插入的
4872,source_code,app\src\main\java\io\legado\app\model\analyzeRule\AnalyzeByJSoup.kt,331,,所以这里也逆向遍历,nên ở đây cũng duyệt ngược,ndexes为空，表明是非[]式索引，集合是逆向遍历插入的，所以这里也逆向遍历，好还原顺序,Chinese parts: 所以这里也逆向遍历
4873,source_code,app\src\main\java\io\legado\app\model\analyzeRule\AnalyzeByJSoup.kt,331,,好还原顺序,để khôi phục thứ tự,明是非[]式索引，集合是逆向遍历插入的，所以这里也逆向遍历，好还原顺序,Chinese parts: 好还原顺序
4874,source_code,app\src\main\java\io\legado\app\model\analyzeRule\AnalyzeByJSoup.kt,334,,将正数不越界的索引添加到集合,Thêm các chỉ mục dương không vượt giới hạn vào tập hợp,until len) indexSet.add(it) //将正数不越界的索引添加到集合,Chinese parts: 将正数不越界的索引添加到集合
4875,source_code,app\src\main\java\io\legado\app\model\analyzeRule\AnalyzeByJSoup.kt,335,,将负数不越界的索引添加到集合,Thêm các chỉ mục âm không vượt giới hạn vào tập hợp,-it) indexSet.add(it + len) //将负数不越界的索引添加到集合,Chinese parts: 将负数不越界的索引添加到集合
4876,source_code,app\src\main\java\io\legado\app\model\analyzeRule\AnalyzeByJSoup.kt,337,,不空,Không trống,tIndexes downTo 0) { //indexes不空，表明是[]式索引，集合是逆向遍历插入的，所以这里也逆向遍历,Chinese parts: 不空
4877,source_code,app\src\main\java\io\legado\app\model\analyzeRule\AnalyzeByJSoup.kt,337,,表明是,Cho thấy là,dexes downTo 0) { //indexes不空，表明是[]式索引，集合是逆向遍历插入的，所以这里也逆向遍历，好还原,Chinese parts: 表明是
4878,source_code,app\src\main\java\io\legado\app\model\analyzeRule\AnalyzeByJSoup.kt,337,,式索引,chỉ mục kiểu,downTo 0) { //indexes不空，表明是[]式索引，集合是逆向遍历插入的，所以这里也逆向遍历，好还原顺序,Chinese parts: 式索引
4879,source_code,app\src\main\java\io\legado\app\model\analyzeRule\AnalyzeByJSoup.kt,337,,集合是逆向遍历插入的,Tập hợp được chèn theo thứ tự ngược,nTo 0) { //indexes不空，表明是[]式索引，集合是逆向遍历插入的，所以这里也逆向遍历，好还原顺序,Chinese parts: 集合是逆向遍历插入的
4880,source_code,app\src\main\java\io\legado\app\model\analyzeRule\AnalyzeByJSoup.kt,337,,所以这里也逆向遍历,nên ở đây cũng duyệt ngược,indexes不空，表明是[]式索引，集合是逆向遍历插入的，所以这里也逆向遍历，好还原顺序,Chinese parts: 所以这里也逆向遍历
4881,source_code,app\src\main\java\io\legado\app\model\analyzeRule\AnalyzeByJSoup.kt,337,,好还原顺序,để khôi phục thứ tự,表明是[]式索引，集合是逆向遍历插入的，所以这里也逆向遍历，好还原顺序,Chinese parts: 好还原顺序
4882,source_code,app\src\main\java\io\legado\app\model\analyzeRule\AnalyzeByJSoup.kt,339,,区间,Khoảng,"s[ix] is Triple<*, *, *>) { //区间",Chinese parts: 区间
4883,source_code,app\src\main\java\io\legado\app\model\analyzeRule\AnalyzeByJSoup.kt,340,,还原储存时的类型,Khôi phục kiểu khi lưu trữ,"as Triple<Int?, Int?, Int> //还原储存时的类型",Chinese parts: 还原储存时的类型
4884,source_code,app\src\main\java\io\legado\app\model\analyzeRule\AnalyzeByJSoup.kt,342,,左端省略表示,Bỏ qua đầu trái nghĩa là,var start = startX ?: 0 // 左端省略表示0,Chinese parts: 左端省略表示
4885,source_code,app\src\main\java\io\legado\app\model\analyzeRule\AnalyzeByJSoup.kt,343,,将负索引转正,Chuyển chỉ mục âm thành dương,f (start < 0) start += len // 将负索引转正,Chinese parts: 将负索引转正
4886,source_code,app\src\main\java\io\legado\app\model\analyzeRule\AnalyzeByJSoup.kt,345,,右端省略表示,Bỏ qua đầu phải nghĩa là,ar end = endX ?: (len - 1) // 右端省略表示 len - 1,Chinese parts: 右端省略表示
4887,source_code,app\src\main\java\io\legado\app\model\analyzeRule\AnalyzeByJSoup.kt,346,,将负索引转正,Chuyển chỉ mục âm thành dương,if (end < 0) end += len // 将负索引转正,Chinese parts: 将负索引转正
4888,source_code,app\src\main\java\io\legado\app\model\analyzeRule\AnalyzeByJSoup.kt,353,,右端越界,Vượt giới hạn đầu phải,rt >= len) start = len - 1 // 右端越界，设置为最大索引,Chinese parts: 右端越界
4889,source_code,app\src\main\java\io\legado\app\model\analyzeRule\AnalyzeByJSoup.kt,353,,设置为最大索引,Đặt làm chỉ mục tối đa,len) start = len - 1 // 右端越界，设置为最大索引,Chinese parts: 设置为最大索引
4890,source_code,app\src\main\java\io\legado\app\model\analyzeRule\AnalyzeByJSoup.kt,354,,左端越界,Vượt giới hạn đầu trái,e if (start < 0) start = 0 // 左端越界，设置为最小索引,Chinese parts: 左端越界
4891,source_code,app\src\main\java\io\legado\app\model\analyzeRule\AnalyzeByJSoup.kt,354,,设置为最小索引,Đặt làm chỉ mục tối thiểu,(start < 0) start = 0 // 左端越界，设置为最小索引,Chinese parts: 设置为最小索引
4892,source_code,app\src\main\java\io\legado\app\model\analyzeRule\AnalyzeByJSoup.kt,356,,右端越界,Vượt giới hạn đầu phải,(end >= len) end = len - 1 // 右端越界，设置为最大索引,Chinese parts: 右端越界